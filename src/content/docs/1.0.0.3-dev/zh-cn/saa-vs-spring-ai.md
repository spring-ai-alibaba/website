---
title: "SAA 与 Spring AI：架构定位与关系"
description: "阐明 Spring AI Alibaba (SAA) 与 Spring AI 之间的架构关系、功能区别与协作模式。"
---

## 核心定位

理解 Spring AI Alibaba (SAA) 与原生 Spring AI 之间的关系，是进行技术选型和架构设计的关键。

**SAA 与 Spring AI 是互补关系，而非替代关系。**

-   **Spring AI** 是一个**基础能力抽象框架**，其核心目标是为开发者提供一个统一的、与具体模型无关的 API，用于访问底层 AI 模型的原子能力（如对话、嵌入等）。

-   **SAA** 是一个**智能体应用与编排框架**，其核心目标是提供一套完整的工具和模式，用于构建、管理和编排有状态的、能够执行复杂任务的智能体（Agent）。

## 架构分层

在典型的 AI 应用技术栈中，两者位于不同的层次：

-   **应用与编排层 (SAA)**：在这一层，开发者关注的是业务逻辑的实现、复杂工作流的定义、智能体的状态管理以及多智能体的协作。SAA 的 `StateGraph` 和 `FlowAgent` 等组件正是在此层发挥作用。

-   **基础能力抽象层 (Spring AI)**：在这一层，框架关注的是如何屏蔽底层不同 AI 模型的接口差异，提供一个稳定、统一的编程界面。Spring AI 的 `ChatClient` 和 `EmbeddingClient` 是这一层的核心。

-   **模型服务层**：即具体的 AI 模型提供商，如阿里云通义、OpenAI、Azure 等。

SAA 作为上层框架，会调用 Spring AI 提供的下层能力。

## 功能域对比

| 特性维度 | Spring AI | SAA (Spring AI Alibaba) |
| :--- | :--- | :--- |
| **主要抽象** | `ChatClient`, `EmbeddingClient` | `StateGraph`, `Agent`, `Node` |
| **核心职责** | 提供模型无关的**原子能力**访问 | 提供**有状态工作流**的编排与管理 |
| **状态管理** | 默认**无状态**（或需自行实现简单会话管理） | **原生支持**，通过 `StateGraph` 实现状态的持久化、中断与恢复 |
| **控制流** | 传统的代码驱动（编程式） | 图驱动的**声明式**控制流，支持条件路由、循环和并行 |
| **设计目标** | 简化对基础 AI 能力的调用 | 简化复杂、多步骤、自主型智能体的构建 |

## 集成与协作模式

SAA 与 Spring AI 之间是典型的**依赖注入和分层调用**的协作关系。

在 SAA 的 `StateGraph` 中，负责与大语言模型交互的 `LlmNode` 节点，其内部依赖并调用了 Spring AI 提供的 `ChatClient` 接口来完成与模型的通信。

这种设计带来了显著的架构优势：

1.  **关注点分离**：SAA 的开发者可以专注于设计智能体的状态流转和业务逻辑，而 Spring AI 则负责处理与底层模型交互的复杂性。
2.  **模型可移植性**：得益于 Spring AI 的模型无关设计，任何被 Spring AI 支持的模型（如 OpenAI, Azure, HuggingFace, Ollama 等），都可以在 SAA 中无缝切换使用，无需修改 SAA 层的任何代码。

## 技术选型与应用场景

-   **推荐单独使用 Spring AI 的场景**：
    -   在现有应用中集成简单的单轮或多轮对话功能。
    -   构建 RESTful API，将 LLM 的文本生成、摘要等能力封装为服务。
    -   执行基于嵌入向量的相似度计算和检索。

-   **推荐使用 SAA 的场景**：
    -   构建需要自主规划和多步工具调用的 ReAct 风格智能体。
    -   设计由多个专业智能体协作完成复杂任务的多智能体系统（如 Supervisor-Executor 模式）。
    -   实现可被中断、恢复和监控的长时间运行的业务流程（例如，需要人工审批的自动化流程）。
    -   需要对智能体的完整执行过程进行可视化追踪和调试。
