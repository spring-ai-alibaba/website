---
title: "A2A (Agent-to-Agent Protocol)"
description: "理解 A2A (智能体间协议) 的核心理念、关键概念，它如何实现不同智能体之间的无缝协作，以及它与 MCP 的关键区别。"
---

## 核心理念：让智能体“相互对话”

如果说 [MCP](./mcp) 协议为 AI 应用提供了连接外部**工具**的“USB-C”端口，那么 **A2A (Agent-to-Agent) 协议** 则为**智能体与智能体之间**的直接沟通和协作提供了标准的“同声传译系统”。

在复杂的业务场景中，我们往往需要构建一个由多个专业智能体组成的“团队”来协同完成任务。例如，一个“旅行规划总管”Agent 可能需要与“机票预订”Agent、“酒店预订”Agent 和“当地活动推荐”Agent 进行协作。

**A2A 协议**正是为了解决这个“智能体团队协作”问题而设计的开放标准。它定义了一套通用的语言和交互规范，使得由不同技术、不同团队、甚至不同公司开发的智能体，都能够相互发现、理解并调用对方的能力。

## 为什么需要 A2A？它解决了什么问题？

在没有 A2A 协议之前，要实现上述的“旅行规划团队”协作，将面临巨大挑战：

-   **定制化的集成**：每个 Agent 之间的交互都需要编写特定的、点对点的集成代码，导致巨大的开发和维护成本。
-   **能力限制**：一种常见的“捷径”是将一个 Agent 降级封装成一个简单的**工具 (Tool)**，然后通过 MCP 协议去调用它。但这严重限制了 Agent 的能力，因为 Agent 之间通常需要进行更复杂的交互，例如多轮对话、任务协商、状态同步等，这些是简单的“工具调用”无法承载的。
-   **生态孤岛**：每个 Agent 系统都成为一个封闭的“孤岛”，无法与外部生态进行高效的、自发的协作。

A2A 协议通过提供一套标准的智能体暴露、发现和通信机制，完美地解决了这些问题，使得构建**可扩展的、开放的、分布式的多智能体系统**成为可能。

## A2A 的核心参与者

A2A 协议定义了通信中的三个核心角色：

-   **用户 (User)**: 任务的最终发起者，可以是一个人，也可以是另一个自动化服务。
-   **A2A Client (客户端智能体)**: 代表用户，主动向其他智能体发起通信的智能体。
-   **A2A Server (远程智能体)**: 接收来自客户端智能体的请求，处理任务，并返回结果的服务方智能体。

## A2A 的核心通信元素

A2A 协议的强大之处在于它定义了一套丰富的通信“积木块”，来支撑复杂的协作流程：

| 元素 | 描述 | 核心价值 |
| :--- | :--- | :--- |
| **智能体名片 (Agent Card)** | 一个 JSON 格式的元数据文档，描述了智能体的身份、能力、通信地址和安全要求。 | Agent 的“身份证”，是实现**服务发现**和安全交互的基础。 |
| **任务 (Task)** | 一个**有状态的**、可被长期追踪的工作单元，拥有唯一的 ID 和生命周期（如已提交、进行中、已完成）。 | A2A 的灵魂。它使 Agent 间的**长周期、异步协作**成为可能，而不仅是简单的一问一答。 |
| **消息 (Message)** | 两个智能体之间的一次**单轮通信**，包含具体的指令、问题或回复。 | 构成 `Task` 内部具体的交互内容。 |
| **分片 (Part)** | 消息内容的基本载体，可以是文本 (`TextPart`)、文件 (`FilePart`) 或结构化数据 (`DataPart`)。 | 赋予了 A2A **多模态通信**的能力，让 Agent 之间可以交换丰富的内容。 |
| **工件 (Artifact)** | `Task` 执行过程中产出的**具体成果物**，例如一份分析报告、一张生成图片或一段代码。 | `Task` 的最终交付价值，是可被追溯和使用的 tangible output。 |

## A2A vs. MCP：关键区别

在理解了 A2A 的核心元素后，我们可以更精确地辨析它与 MCP 的定位：

-   **MCP (Model Context Protocol)**
    -   **核心**：围绕**无状态的工具调用 (Tool Call)**。
    -   **关系**：主从关系 (Agent -> Tool)。
    -   **交互**：简单、一次性的请求-响应，类似于**同步的函数调用**。

-   **A2A (Agent-to-Agent Protocol)**
    -   **核心**：围绕**有状态的任务 (Task)**。
    -   **关系**：对等关系 (Agent <-> Agent)。
    -   **交互**：支持复杂的、长周期的、**异步的协作流程**，允许多轮协商和状态追踪。

> **核心思想**：工具是 Agent 的“手和脚”，而其他 Agent 则是 Agent 的“同事”。我们用 MCP 来指挥“手脚”，用 A2A 来与“同事”协作。

## SAA 的实现

SAA 框架通过 `spring-ai-alibaba-a2a` 模块，为 A2A 协议提供了原生的支持。

开发者可以使用 SAA，将任何一个基于 `StateGraph` 构建的复杂智能体，一键式地**发布**为一个 A2A Server。这意味着：

-   你的 SAA Agent 可以对外提供一个标准的 `AgentCard`。
-   它能够接收外部 A2A Client 发来的请求，将其转化为一个内部的 `Task` 并通过 `StateGraph` 进行处理。
-   在处理过程中，它可以异步地返回 `Message` 和 `Artifact`，实现与其他智能体的复杂协作。

这极大地增强了 SAA 智能体的**互操作性**和**服务化**能力，是构建企业级分布式智能体系统的关键一环。

## 进一步阅读

A2A 是一个由 Google 等公司共同推动的开放标准，旨在构建一个更加开放和协作的 AI 生态系统。

> 我们强烈建议您阅读 [A2A 官方文档](https://a2a-protocol.org/) 以深入了解其协议规范和更多用例。
