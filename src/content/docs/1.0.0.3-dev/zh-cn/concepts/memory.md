---
title: "记忆 (Memory)"
description: "理解记忆 (Memory) 在构建有状态、连贯的智能体中的核心作用，以及 SAA 如何通过其独特的架构提供强大的记忆能力。"
---

## 什么是记忆？

对于一个 Java Web 开发者来说，理解智能体“记忆”最快的类比是 **`HttpSession`**。

我们知道，HTTP 协议本身是无状态的。为了在多个连续的 HTTP 请求之间维持用户的登录状态或购物车信息，我们需要 `HttpSession` 这样的会话管理机制。

同样地，对大语言模型（LLM）的单次 API 调用也是**无状态的**。如果你不采取任何措施，LLM 无法记起你们之前的任何对话。**记忆 (Memory)** 机制的引入，正是为了解决这个问题，它赋予了智能体**在多次交互之间保持状态和上下文的能力**。

## 为什么 Agent 需要记忆？

没有记忆的 Agent 只能处理简单的、一问一答式的任务。一旦任务变得复杂，需要多步骤推理、利用历史信息或与用户进行持续对话，记忆就变得至关重要。它解决了以下核心问题：

-   **对话的连贯性**：记住之前的交流内容，使对话能够自然地延续。
-   **任务的连续性**：在执行一个多步骤任务时，记住之前的操作结果和中间状态。
-   **个性化**：记住用户的偏好和历史行为，提供更具个性化的服务。
-   **长任务的中断与恢复**：对于需要长时间运行（数小时甚至数天）的任务，记忆机制可以将其状态持久化，以便在系统重启或计划中断后能够从断点处恢复执行。

## 记忆的两种类型

在构建 Agent 时，我们通常会区分两种不同生命周期的记忆：

### 1. 短期记忆 (Short-term Memory)

短期记忆，也常被称为**工作流记忆**或**暂存区 (Scratchpad)**，它的作用域是**单个连续的任务会话**。

-   **核心职责**：在一个从开始到结束的完整任务流程中，记录所有的中间状态、对话历史、工具调用结果等。一旦任务完成，这份记忆通常也随之销毁。
-   **SAA 实现**：在 SAA 中，短期记忆的核心实现就是 **`StateGraph` 的状态对象 (`State`)**。`StateGraph` 的设计哲学决定了它是一个**原生有状态**的执行引擎。整个 `State` 对象在图的节点之间流转，并被每个节点不断更新。这个 `State` 对象本身就是对当前任务最完整的短期记忆。

### 2. 长期记忆 (Long-term Memory)

长期记忆则超越了单次任务的范畴，它的数据需要被**持久化**，以便在**未来的不同任务或会话**中被重新加载和使用。

-   **核心职责**：
    1.  存储需要跨会话使用的信息，如用户偏好、累积的知识等。
    2.  实现长时间运行任务的**中断与恢复**。
-   **SAA 实现**：SAA 通过其 **`Checkpoint` (检查点)** 机制来实现长期记忆。`Checkpoint` 可以将一个 `StateGraph` 实例的完整状态（即它的全部短期记忆）随时**序列化并保存**到外部存储中（如 Redis、数据库或文件系统）。当需要时，可以从这个检查点完美地恢复 Agent 的运行状态，继续执行任务。

## 进一步阅读

对于一些更简单的、纯对话驱动的场景，Spring AI 框架本身也提供了开箱即用的、以**聊天历史为核心**的记忆功能，它可以与 `ChatClient` 无缝集成。SAA 的记忆模型是对此的补充和增强，旨在服务于更复杂的、有状态的工作流。

> 如果你的需求主要是维持对话的上下文，可以进一步阅读 [Spring AI 官方关于聊天记忆的文档](https://docs.spring.io/spring-ai/reference/api/chat-memory.html)。

